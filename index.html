<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Anyway.MBTI Zoo</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Quicksand:wght@700&display=swap");

      :root {
        --bg-color: #fffdf5;
      }

      body {
        margin: 0;
        width: 100vw;
        height: 100vh;
        background-color: var(--bg-color);
        font-family: "Quicksand", "Microsoft YaHei", sans-serif;
        overflow: hidden;
        user-select: none;
        /* 可爱的猫爪鼠标指针 */
        cursor: url('data:image/svg+xml;utf8,<svg width="28" height="28" viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg"><ellipse cx="14" cy="18" rx="5" ry="6" fill="%23FFB6C1"/><circle cx="7" cy="10" r="3" fill="%23FFB6C1"/><circle cx="14" cy="8" r="3" fill="%23FFB6C1"/><circle cx="21" cy="10" r="3" fill="%23FFB6C1"/></svg>')
            14 14,
          auto;
      }

      /* 隐藏原有的 Header，什么都不留 */

      /* === 核心容器 === */
      .critter {
        position: absolute;
        width: 40px;
        height: 40px;
        will-change: transform;
        z-index: 10;
        /* 扩大一点点击区域，更好抓 */
        padding: 20px;
        margin: -20px;
      }

      /* === 视觉包裹层 (负责左右翻转) === */
      .visual-wrapper {
        width: 40px;
        height: 40px;
        position: relative;
        transition: transform 0.2s;
        /* 修正 pointer-events 以便父级能捕获hover */
        pointer-events: auto;
      }

      .facing-right {
        transform: scaleX(-1);
      }

      /* === 身体 (负责上下浮动 & 颜色) === */
      .body {
        width: 100%;
        height: 100%;
        border-radius: 45% 45% 40% 40%; /* 稍微圆一点 */
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        /* 默认阴影 */
        box-shadow: inset -3px -3px 10px rgba(0, 0, 0, 0.05),
          0 5px 10px rgba(0, 0, 0, 0.1);
        transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); /* 弹性过渡 */
        z-index: 2;
      }

      /* 走路时的颠簸动画 */
      .critter.walking .body {
        animation: bob 0.6s infinite alternate ease-in-out;
      }
      @keyframes bob {
        0% {
          transform: translateY(0);
        }
        100% {
          transform: translateY(-6px);
        }
      }

      /* 表情文字 */
      .face {
        font-size: 11px;
        color: rgba(60, 60, 60, 0.7);
        font-weight: bold;
        pointer-events: none;
        transition: transform 0.1s;
      }

      /* === 腿部系统 === */
      .legs {
        position: absolute;
        bottom: -6px;
        width: 100%;
        height: 15px;
        display: flex;
        justify-content: center;
        gap: 12px;
        z-index: 1;
        pointer-events: none;
      }
      .leg {
        width: 6px;
        height: 10px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 4px;
        transition: all 0.2s;
      }

      /* 走路腿动 */
      .critter.walking .leg:nth-child(1) {
        animation: walk-l 0.4s infinite alternate;
      }
      .critter.walking .leg:nth-child(2) {
        animation: walk-r 0.4s infinite alternate;
        animation-delay: 0.2s;
      }
      @keyframes walk-l {
        from {
          transform: rotate(-20deg) translateY(0);
        }
        to {
          transform: rotate(20deg) translateY(-3px);
        }
      }
      @keyframes walk-r {
        from {
          transform: rotate(20deg) translateY(-3px);
        }
        to {
          transform: rotate(-20deg) translateY(0);
        }
      }

      /* === ✨ HOVER 特效：拎起来！ ✨ === */

      .critter:hover {
        z-index: 999;
        cursor: grab;
      }

      /* 1. 身体上浮，阴影变远 */
      .critter:hover .body {
        animation: none; /* 停止走路颠簸 */
        transform: translateY(-20px) scale(1.05); /* 向上提 */
        box-shadow: 0 30px 30px rgba(0, 0, 0, 0.15); /* 阴影拉长 */
        filter: brightness(1.05); /* 稍微变亮 */
      }

      /* 2. 腿变长并乱蹬 (悬空感) */
      .critter:hover .leg {
        animation: none;
        height: 22px; /* 腿被重力拉长 */
        width: 4px;
        animation: panic-legs 0.1s infinite alternate; /* 快速抖动 */
      }
      /* 乱蹬动画 */
      @keyframes panic-legs {
        from {
          transform: rotate(-15deg);
        }
        to {
          transform: rotate(15deg);
        }
      }
      .critter:hover .leg:nth-child(2) {
        animation-delay: 0.05s;
      }

      /* 3. 气泡显示 */
      .info-bubble {
        position: absolute;
        bottom: 90px; /* 气泡位置也稍微高一点 */
        left: 50%;
        transform: translateX(-50%) scale(1);
        background: rgba(50, 50, 50, 0.9);
        color: #fff;
        padding: 2px 5px;
        border-radius: 8px;
        font-size: 6px;
        white-space: nowrap;
        opacity: 1;
        transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        pointer-events: none;
        z-index: 99;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      }
      .info-bubble::after {
        content: "";
        position: absolute;
        bottom: -4px;
        left: 50%;
        margin-left: -4px;
        border-width: 4px 4px 0;
        border-style: solid;
        border-color: rgba(50, 50, 50, 0.9) transparent transparent transparent;
      }
      .critter:hover .info-bubble {
        transform: translateX(-50%) scale(1.1);
      }

      .name-row {
        display: flex;
        align-items: center;
        gap: 2px;
      }
      .name {
        font-weight: 700;
        font-size: 6px;
      }
      .mbti-tag {
        font-size: 5px;
        background: rgba(255, 255, 255, 0.2);
        padding: 0px 2px;
        border-radius: 2px;
      }

      /* 形状变体 */
      .shape-triangle .body {
        border-radius: 10px;
        clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
        height: 44px;
        width: 47px;
      }
      .shape-triangle .face {
        margin-top: 10px;
      }
      .shape-square .body {
        border-radius: 8px;
      }

      /* 地面线 */
      .floor-line {
        position: absolute;
        bottom: 0;
        width: 100%;
        height: 8px;
        background: repeating-linear-gradient(
          to right,
          #e0e0e0 0,
          #e0e0e0 10px,
          transparent 10px,
          transparent 20px
        );
        opacity: 0.6;
      }
    </style>
  </head>
  <body>
    <div id="zoo-container"></div>
    <div class="floor-line"></div>

    <script>
      // MBTI 类型配色方案
      const mbtiStyles = {
        INTJ: { color: "#957DAD", shape: "circle" },
        ENTJ: { color: "#E0BBE4", shape: "square" },
        INTP: { color: "#D291BC", shape: "circle" },
        ENTP: { color: "#D291BC", shape: "triangle" },
        INFJ: { color: "#B5EAD7", shape: "circle" },
        ENFJ: { color: "#FF9AA2", shape: "triangle" },
        INFP: { color: "#C7CEEA", shape: "circle" },
        ENFP: { color: "#FFB7B2", shape: "circle" },
        ISTJ: { color: "#FDFD96", shape: "square" },
        ESTJ: { color: "#FFDAC1", shape: "triangle" },
        ISTP: { color: "#FFA07A", shape: "circle" },
        ESTP: { color: "#FFDAC1", shape: "circle" },
        ISFJ: { color: "#E2F0CB", shape: "circle" },
        ESFJ: { color: "#E2F0CB", shape: "square" },
        ISFP: { color: "#DDA0DD", shape: "circle" },
        ESFP: { color: "#F0E68C", shape: "triangle" },
      };

      let characters = [];

      // 根据性格类型的表情集合
      const facesByType = {
        // 内向型 - 更内敛、害羞
        I: {
          normal: ["• _ •", "- ◡ -", "˘ ˘", "- . -", "◡‿◡", "- ω -", "˘︶˘"],
          panic: [">///<", "o///o", ">_<", "⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄", "(*ﾟ▽ﾟ*)", ">//<"],
        },
        // 外向型 - 更活泼、开朗
        E: {
          normal: ["^▽^", "≧◡≦", "◕‿◕", "ʘ‿ʘ", "★ω★", "✧◡✧", "⌒‿⌒"],
          panic: ["O_O", "◎ω◎", "ΩДΩ", "!!!", "⊙▽⊙", "☆_☆", "◉_◉"],
        },
        // 思考型 - 更冷静、理性
        T: {
          normal: ["- _ -", "¬_¬", "•_•", "- .- ", "︶_︶", "ー_ー", "—_—"],
          panic: ["⊙_⊙", "°_°", "◔_◔", "ಠ_ಠ", "⊙ω⊙", "°Д°"],
        },
        // 情感型 - 更温暖、感性
        F: {
          normal: ["♡‿♡", "◠‿◠", "uwu", "◡‿◡", "☺‿☺", "^‿^", "◕‿‿◕"],
          panic: ["QAQ", "TωT", ">3<", "⊙﹏⊙", "(╥﹏╥)", "°^°"],
        },
      };

      const container = document.getElementById("zoo-container");

      class Critter {
        constructor(data) {
          this.data = data;
          this.element = null;
          this.wrapper = null;
          this.faceElement = null;
          this.originalFace = "";
          this.normalFaces = [];
          this.panicFaces = [];

          this.x = Math.random() * (window.innerWidth - 80);
          this.y = Math.random() * (window.innerHeight - 150) + 50;

          // 根据性格设置速度 - 让差异更明显
          // EP型（外向+知觉）：最好动，如 ESFP, ESTP, ENFP, ENTP
          // EJ型（外向+判断）：比较好动
          // IP型（内向+知觉）：比较安静但偶尔活跃
          // IJ型（内向+判断）：最不好动，如 INFJ, INTJ, ISFJ, ISTJ
          let speedMultiplier = 1.0;

          if (data.ie === "E" && data.pj === "P") {
            speedMultiplier = 2.0; // EP型非常好动
          } else if (data.ie === "E" && data.pj === "J") {
            speedMultiplier = 1.4; // EJ型比较好动
          } else if (data.ie === "I" && data.pj === "P") {
            speedMultiplier = 0.7; // IP型比较安静
          } else if (data.ie === "I" && data.pj === "J") {
            speedMultiplier = 0.3; // IJ型非常安静，几乎不动
          }

          const baseSpeed = 0.3 + Math.random() * 0.6;
          this.speed = baseSpeed * speedMultiplier;

          this.dx = (Math.random() - 0.5) * this.speed;
          this.dy = (Math.random() - 0.5) * this.speed;

          this.isHovered = false;
          this.setupFaces();
          this.init();
        }

        setupFaces() {
          // 根据 I/E 和 T/F 选择表情风格
          const ieType = this.data.ie;
          const tfType = this.data.tf;

          // 混合 I/E 和 T/F 的表情
          this.normalFaces = [
            ...facesByType[ieType].normal,
            ...facesByType[tfType].normal,
          ];
          this.panicFaces = [
            ...facesByType[ieType].panic,
            ...facesByType[tfType].panic,
          ];
        }

        init() {
          this.element = document.createElement("div");
          this.element.className = "critter walking";
          if (this.data.shape === "triangle")
            this.element.classList.add("shape-triangle");
          if (this.data.shape === "square")
            this.element.classList.add("shape-square");

          this.originalFace =
            this.normalFaces[
              Math.floor(Math.random() * this.normalFaces.length)
            ];

          this.element.innerHTML = `
                    <div class="info-bubble">
                        <div class="name-row">
                            <span class="name">${this.data.name}</span>
                            <span class="mbti-tag">${this.data.type}</span>
                        </div>
                    </div>
                    <div class="visual-wrapper">
                        <div class="body" style="background-color: ${this.data.color};">
                            <div class="face">${this.originalFace}</div>
                        </div>
                        <div class="legs">
                            <div class="leg"></div>
                            <div class="leg"></div>
                        </div>
                    </div>
                `;

          container.appendChild(this.element);
          this.wrapper = this.element.querySelector(".visual-wrapper");
          this.faceElement = this.element.querySelector(".face");

          // === 交互逻辑 ===
          this.element.addEventListener("mouseenter", () => {
            this.isHovered = true;
            // 1. 随机换一个"惊慌"表情
            const panicFace =
              this.panicFaces[
                Math.floor(Math.random() * this.panicFaces.length)
              ];
            this.faceElement.innerText = panicFace;
          });

          this.element.addEventListener("mouseleave", () => {
            this.isHovered = false;
            // 2. 恢复原来的淡定表情
            this.faceElement.innerText = this.originalFace;

            // 3. 被放下后，换个方向跑 (假装受惊逃跑)
            // EP型逃得最快，IJ型几乎不逃
            let escapeSpeed = 1.5;
            if (this.data.ie === "E" && this.data.pj === "P") {
              escapeSpeed = 3.5; // EP型：疯狂逃跑
            } else if (this.data.ie === "E" && this.data.pj === "J") {
              escapeSpeed = 2.5; // EJ型：快速逃跑
            } else if (this.data.ie === "I" && this.data.pj === "P") {
              escapeSpeed = 1.5; // IP型：温和逃跑
            } else if (this.data.ie === "I" && this.data.pj === "J") {
              escapeSpeed = 0.8; // IJ型：淡定离开
            }
            this.dx = (Math.random() - 0.5) * escapeSpeed;
            this.dy = (Math.random() - 0.5) * escapeSpeed;
          });
        }

        update() {
          if (this.isHovered) return; // 被抓住时，位置不动

          this.x += this.dx;
          this.y += this.dy;

          // 边界反弹
          if (this.x <= 20 || this.x >= window.innerWidth - 80) {
            this.dx *= -1;
          }
          if (this.y <= 20 || this.y >= window.innerHeight - 80) {
            this.dy *= -1;
          }

          // 偶尔发呆转向 - 让好动的性格更活跃
          // EP型转向最频繁，IJ型几乎不转向
          let turnFrequency = 0.005; // 默认
          if (this.data.ie === "E" && this.data.pj === "P") {
            turnFrequency = 0.015; // EP型：频繁转向，活泼好动
          } else if (this.data.ie === "E" && this.data.pj === "J") {
            turnFrequency = 0.008; // EJ型：适度转向
          } else if (this.data.ie === "I" && this.data.pj === "P") {
            turnFrequency = 0.004; // IP型：偶尔转向
          } else if (this.data.ie === "I" && this.data.pj === "J") {
            turnFrequency = 0.001; // IJ型：极少转向，稳如泰山
          }

          if (Math.random() < turnFrequency) {
            this.dx = (Math.random() - 0.5) * this.speed * 1.5;
            this.dy = (Math.random() - 0.5) * this.speed * 1.5;
          }

          // 移动
          this.element.style.transform = `translate(${this.x}px, ${this.y}px)`;

          // 转向 (控制内部wrapper)
          if (this.dx > 0) {
            this.wrapper.classList.add("facing-right");
          } else {
            this.wrapper.classList.remove("facing-right");
          }
        }
      }

      // 从 API 获取数据并初始化
      const critters = [];

      async function loadCharacters() {
        try {
          const response = await fetch("https://anyway.fm/api/mbti.php");
          const result = await response.json();

          // API 返回的数据在 result.data.items 里
          const items = result.data.items;

          // 转换 API 数据为我们需要的格式
          characters = items.map((person) => {
            const mbtiType = person.mbti.toUpperCase();
            const style = mbtiStyles[mbtiType] || {
              color: "#CCCCCC",
              shape: "circle",
            };

            return {
              name: person.nickname,
              type: mbtiType,
              color: style.color,
              shape: style.shape,
              ie: person.ie.toUpperCase(), // I 或 E
              ns: person.ns.toUpperCase(), // N 或 S
              tf: person.tf.toUpperCase(), // T 或 F
              pj: person.pj.toUpperCase(), // P 或 J
            };
          });

          // 初始化所有小生物
          characters.forEach((data) => critters.push(new Critter(data)));
        } catch (error) {
          console.error("Failed to load characters:", error);
        }
      }

      function animate() {
        critters.forEach((c) => c.update());
        requestAnimationFrame(animate);
      }

      // 启动
      loadCharacters();
      animate();

      window.addEventListener("resize", () => {
        critters.forEach((c) => {
          if (c.x > window.innerWidth) c.x = window.innerWidth - 100;
          if (c.y > window.innerHeight) c.y = window.innerHeight - 100;
        });
      });
    </script>
  </body>
</html>
